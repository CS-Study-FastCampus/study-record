# 5.3.2 트리

### (1) 트리란 무엇인가?

- 비선형 자료구조 중 하나입니다.
- 계층적 관계를 표현하는 자료구조입니다.

<br><br>

### (2) 트리를 시작하기 전 용어 정리

- **노드 (Node)**
    - A에서 B를 지나서 C로 간다고 할 때, A, B, C를 노드(Node) 또는 정점(Vertex)이라고 합니다.
    - 트리를 구성하는 각각의 요소를 뜻합니다.
- **간선 (Edge)**
    - A에서 B를 지나서 C로 간다고 할 때, 지나가는 노드 사이의 길을 간선(Edge)라고 합니다.
    - 노드와 노드를 연결하는 선을 의미합니다.
- **루트 노드 (Root Node)**
    - 트리에서 가장 위에 있는 노드를 의미합니다.
- **리프 노드 (Leaf Node, Terminal Node)**
    - 자식 노드를 가지고 있지 않은 노드를 의미합니다.
    - 말단 노드라고도 불립니다.
- **내부 노드 (Internal Node)**
    - 리프 노드를 제외한 모든 노드를 내부 노드라고 부릅니다. 여기에는 루트 노드도 포함됩니다.

![image](https://user-images.githubusercontent.com/70641477/232485234-34ccf589-73bf-4939-80ee-9d0e97d6d633.png)

<br><br>

### (3) 트리의 특징

- 부모와 자식 계층 구조를 가지고 있습니다.
- 간선(Edge)의 수는 노드(Node)의 수에서 1을 뺀 값입니다. (간선의 수 = 노드의 수 - 1)
- 임의의 두 노드 사이의 경로는 “유일 무이”하게 존재합니다.
    - 위에 예시 그림을 봤을 때, 30에서 25로 가는 경로를 한번 생각해봅시다.
    - 30 → 21 → 25의 경로로 유일 무이하다는 것입니다. 30 → 21 → 13 → 21 → 25라는 경로는 존재하지 않습니다.

<br><br>

### (4) 트리의 높이와 레벨

![image](https://user-images.githubusercontent.com/70641477/232485328-9497ae23-4da9-4138-af46-30985043725b.png)

- **깊이**
    - 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리를 말합니다.
    - 예시 그림에서 30에서 25까지의 깊이는 2입니다.
- **트리의 높이**
    - 루트 노드부터 리프 노드까지의 거리 중에서 가장 긴 거리를 의미합니다.
    - 가장 긴 거리인 이유는 위 예시에서 또다른 리프 노드인 13, 25까지의 거리는 2이지만, 트리의 높이는 47까지의 거리인 3입니다.
- **레벨**
    - 레벨은 깊이와 같은 의미를 가집니다. {30}노드가 레벨 0이라면 {21, 46} 노드는 레벨 1이고 {13, 25, 53} 노드는 레벨 2입니다.
    - 루트 노드의 레벨은 0을 갖습니다.
- **서브트리**
    - 트리 안에 트리를 의미합니다. 위 예시 그림에서는 노란색 박스에 있는 부분이 서브트리가 될 수 있습니다.
    

<br><br>

### (5) 이진 트리 (Binary Tree)

- 자식의 노드 수가 2개 이하인 트리를 말합니다.
- **이진 트리의 종류**
    1. **정이진 트리 (Full Binary Tree)**
        - 자식 노드가 0개 또는 2개인 트리를 의미합니다.
    2. **완전 이진 트리(CompleteBinary Tree)**
        - 노드 기준 왼쪽 부터 채워지는 것이 특징입니다.
        - 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있다는 특징이 있습니다.
    3. **변질 이진 트리 (Degenerate Binary Tree)**
        - 자식 노드가 하나뿐인 이진 트리를 의미합니다.
    4. **포화 이진 트리 (Perfect Binary Tree)**
        - 모든 레벨이 꽉 차있는 이진트리를 의미합니다.
    5. **균형 이진 트리 (Balanced Binary Tree)**
        - 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리를 의미합니다.
- 빠르게 정리하고 넘어가는 퀴즈
    - 다음 중 정이진 트리가 아닌 것을 고르세요.
        
        ![image](https://user-images.githubusercontent.com/70641477/232485386-65aa5fbb-b0dc-4174-8f2f-5812ac62d80b.png)
        
        - `정답 2번`
            - 정이진 트리는 자식 노드가 1개 이면 안 됩니다.
            - 2번은 완전 이진 트리라고 할 수 있습니다.
        - 3번은 포화 이진 트리가 아닌가요?
            - 포화 이진 트리를 만족하면 정이진 트리가 됩니다.
            - 하지만 정이진 트리를 만족한다고 해서는 포화 이진 트리가 만족될 수 없습니다.

<br><br>

### (6) 이진 탐색 트리 (Binary Search Tree, BST)

- 이진 탐색 트리는 효율적인 탐색을 위해서 만들어진 트리를 말합니다.
- 이진 트리와 이진 탐색 트리를 같은 종류라고 생각하면 안 됩니다.
- **이진 탐색 트리를 만들기 위한 조건**
    - 이진 탐색 트리에 들어오는 값은 유일한 값이어야 합니다. (중복값 허용 X)
    - 부모 노드의 값이 왼쪽 자식 노드의 값보다 커야 합니다.
    - 부모 노드의 값이 오른쪽 자식 노드의 값보다 작아야 합니다.
    - 왼쪽 노드와 오른쪽 노드로 구성되는 서브 트리도 모두 이진 탐색 트리여야 합니다.
- 이진 탐색 트리를 사용하면 탐색 속도를 O(logn)까지 할 수가 있습니다.
    
    ![image](https://user-images.githubusercontent.com/70641477/232485456-201d85db-4b46-46c0-9bd4-5922dfc3940d.png)
    
    - 위에 있는 이진 탐색 트리에서 12라는 값을 찾고 싶다면 어떻게 찾아야할까?
        1. 루트(25)와 비교합니다. 찾고자하는 12는 25보다 작기 때문에 왼쪽 서브 트리로 갑니다.
        2. 왼쪽 노드(16)과 비교합니다. 찾고자하는 12는 16보다 작기 때문에 왼쪽 트리로 이동합니다.
        3. 12를 찾았습니다.
    - 이렇게 12를 찾기 위해서 절반의 범위씩 잘라내면서 찾아내기 때문에 O(logn)의 시간 복잡도를 갖게됩니다.
- 하지만 데이터를 입력하는 순서에 따라서 이진 탐색 트리도 최악의 경우 O(n)의 시간이 걸립니다.
- 사실 O(n) 시간이 걸린다면 굳이 이진 탐색 트리를 쓸 필요가 없게 됩니다. 배열, 리스트도 O(n)의 탐색 시간이 걸리기 때문입니다.
- 아래와 같은 경우가 이진 탐색 트리의 최악의 경우 입니다.
    
    ![image](https://user-images.githubusercontent.com/70641477/232485581-22c0f375-3c0d-4142-9366-f01c7c425e21.png)
    
    - 12를 찾기 위해서는 요소의 개수인 N만큼 반복해야 하기 때문에 O(N)의 시간 복잡도를 갖게 됩니다.
    - 위와 같은 이진 탐색 트리가 만들어지는 이유는 삽입 순서에 있습니다.
        - 12 → 19 → 16 → 26 순서로 넣게 되면 위와 같은 트리가 형성됩니다.

<br><br>

### (7) AVL 트리

- Adelson-Velsky and Landis tree의 약어로서 앞에서 말했던 최악의 선형 트리가 되는 것을 방지하기 위해서 만들어진 “스스로 균형을 잡는 이진 탐색 트리”입니다.
- 두 자식 서브트리의 높이는 항상 최대 1만큼 차이가 난다는 특징이 있습니다. 즉, 왼쪽과 오른쪽 서브트리의 높이 차이가 1을 넘지 않도록 유지합니다.
    - 트리의 종류에서 균형 이진 트리가 생각납니다.
- AVL 트리는 탐색, 삽입, 삭제에서 모두 O(logn)의 시간 복잡도를 갖고 있습니다.
- 삽입, 삭제를 할 때마다 트리의 높이 균형을 검사합니다. 균형이 깨진 경우 회전 연산을 사용해서 균형을 맞추는 작업을 합니다.
    - 회전 연산의 한 가지 예시를 살펴보겠습니다.
        
        ![image](https://user-images.githubusercontent.com/70641477/232485644-dd6a0612-70d9-4321-80df-6703215983f9.png)
        
        - 위 이진 탐색 트리에서 만약 18이라는 데이터가 들어오게 되면 어떻게 될까요?
            
            ![image](https://user-images.githubusercontent.com/70641477/232485766-88edae4c-89c0-4406-9778-48585a611d6f.png)
            
        - 이런식으로 데이터가 들어오게 되고, AVL 트리에서는 왼쪽과 오른쪽의 높이 균형을 검사합니다. 루트 노드인 12를 기준으로 왼쪽 트리의 높이는 1이고, 오른쪽 트리의 높이는 3이기 때문에 그 차이가 1을 넘어서서 균형잡히지 않은 트리로 판단을 합니다.
        - 이때 회전 연산을 하게 되는데, 노드 15를 그림과 같이 당긴다고 생각을 하고 연산을 진행합니다.
            
            ![image](https://user-images.githubusercontent.com/70641477/232485888-97a5006f-089b-413e-965e-93ff80b2dbbc.png)
            
        - 그리고 노드 15의 **좌측 자식 노드**를 자신의 부모 노드였던 12의 **우측 노드에 연결**합니다.
            
            ![image](https://user-images.githubusercontent.com/70641477/232485916-75817548-2a21-4673-9123-61cc64d1b507.png)
            
        - 이렇게 한 후 AVL 트리의 높이 균형이 맞는지 다시 확인하는 과정을 거치면서 AVL 트리의 형태를 유지합니다.
        - [AVL 트리 이해를 위한 영상](https://www.youtube.com/watch?v=9BiHgy40NNE)

<br><br>

### (8) 레드 블랙 트리

- RBT(Red-Black-Tree)는 BST를 기반으로하는 트리 형식의 자료구조입니다.
- RBT도 AVL과 마찬가지로 최악의 선형 이진 탐색 트리가 되는 것을 방지하기 위한 방법입니다.
- 각 노드는 빨간색과 검은색의 색상을 나타내는 추가 비트를 저장하고 있습니다.
    - 삽입, 삭제를 진행하는 과정에서 트리가 균형을 유지하도록 도와줍니다.
- Root Node와 모든 Leaf Node의 거리 중에서 최소 거리와 최대 거리의 크기 비율이 2보다 크지 않습니다.
- **RBT을 만족하기 위한 규칙**
    1. 각 노드는 Red, Black의 색을 갖습니다.
    2. Root Node의 색은 Black입니다.
    3. Leaf Node의 색은 Black입니다.
    4. 어떤 노드의 색이 Red라면 자식 Node는 Black입니다. -> Red는 연속적으로 존재할 수 없습니다.
    5. Leaf 노드는 논리적으로 Null(Nil) 노드이고, 항상 검정색입니다.
    6. 특정 노드에서 후손 Nil 노드까지 가는 경로에는 동일한 수의 검정색 노드가 존재해야 합니다. -> 자기 자신은 제외합니다.
- Java에서는 AVL 트리로 구현된 Collection 구현체는 존재 하지 않고, TreeMap의 경우 내부적으로 RBT로 이루어져 있다고 합니다.
    
    > "A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.”
    
    출처 [https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/TreeMap.html](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/TreeMap.html)
    >
