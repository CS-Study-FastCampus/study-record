## 해시 테이블

**(1) 해시**
- 해시: 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값
- 해싱: 임의의 데이터를 해시로 바꿔주는 일
- 해시 함수: 임의의 데이터를 입력받아 일정한 길이의 데이터로 바꿔주는 함수 (해싱 하는 함수)

**(2) 테이블**
- 테이블: Key과 Value가 하나의 쌍을 이루는 데이터 구조

**(3) 해시테이블**
- "무한에 가까운" 데이터들을 "유한한 개수"의 해시값으로 매핑한 테이블

- unordered_map으로 구현됨

<br>

## 해시 충돌

다른 내용의 데이터가 해시함수에 의해 같은 값의 Key를 갖는 현상을 **해시 충돌** 이라고 한다.

해시함수의 입력값은 무한하지만 출력값의 가짓수는 유한하기 때문에, 해시충돌은 반드시 발생한다.
<br>

### 해시 충돌의 해결방법

**(1) 체이닝 (Chaining)**

버킷(해시테이블에서 데이터가 저장되는 공간) 내에 연결리스트를 할당하여, 해시 충돌이 일어난 경우 해당 버킷의 next 포인터가 가리키는 노드에 값을 저장한다.

HashTable의 경우 요소의 삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간복잡도를 가지지만,

체이닝 방식으로 해시 충돌을 해결했을 시 연결리스트가 길어진다면, 최악의 경우 연결리스트의 시간복잡도인 O(n)의 시간복잡도를 갖게 될 수도 있다.

**(2) 개방 주소법 (Open Addressing)**

충돌 발생시 다른 버켓에 데이터를 저장하는 방식이다.

- 선형 탐색: 해시 충돌 시 n칸을 건너뛴 다음 버킷에 데이터 저장


  중복되는 해시값이 많을 경우 계속해서 n칸을 건너 뛰어 데이터를 저장할 버킷을 찾아야 하기 때문에 검색 시간이 길어질 수 있으며, 데이터들이 특정 위치에 밀집해 있을 위험성(클러스터 현상이 일어날 가능성)이 높다.

- 제곱 탐색: 해시 충돌 시 n^2칸을 건너뛴 다음 버킷에 데이터 저장


  선형 탐색과 보다 버킷간의 간격이 넓어지기 때문에 클러스터 현상의 가능성은 낮아지지만, 처음 해시값이 동일한 충돌이 많이 발생할 경우 검색 시간이 길어진다는 문제는 여전히 존재한다.

- 이중 해시: 해시값에 다른 해시 함수를 한번 더 적용

첫번째 해시함수를 통해 해시값을 구하며, 해시 충돌이 일어난 경우 해당 해시 값에 두번째 해시 함수를 적용하여 이동할 버킷의 폭을 구한다.

최초의 해시 값이 같더라도 두번째 해시 함수를 해 구해진 이동 폭이 다르기 때문에 클러스터 현상을 피하는데 용이하다. 